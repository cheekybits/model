// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package model

import "errors"

// IsBool checks to make sure the value is a bool.
// Remains silent if the data is not present.
func IsBool(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(bool); !ok {
			return errors.New(key + " must be bool")
		}
	}
	return nil
}

// IsByte checks to make sure the value is a byte.
// Remains silent if the data is not present.
func IsByte(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(byte); !ok {
			return errors.New(key + " must be byte")
		}
	}
	return nil
}

// IsComplex128 checks to make sure the value is a complex128.
// Remains silent if the data is not present.
func IsComplex128(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(complex128); !ok {
			return errors.New(key + " must be complex128")
		}
	}
	return nil
}

// IsComplex64 checks to make sure the value is a complex64.
// Remains silent if the data is not present.
func IsComplex64(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(complex64); !ok {
			return errors.New(key + " must be complex64")
		}
	}
	return nil
}

// IsError checks to make sure the value is a error.
// Remains silent if the data is not present.
func IsError(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(error); !ok {
			return errors.New(key + " must be error")
		}
	}
	return nil
}

// IsFloat32 checks to make sure the value is a float32.
// Remains silent if the data is not present.
func IsFloat32(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(float32); !ok {
			return errors.New(key + " must be float32")
		}
	}
	return nil
}

// IsFloat64 checks to make sure the value is a float64.
// Remains silent if the data is not present.
func IsFloat64(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(float64); !ok {
			return errors.New(key + " must be float64")
		}
	}
	return nil
}

// IsInt checks to make sure the value is a int.
// Remains silent if the data is not present.
func IsInt(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(int); !ok {
			return errors.New(key + " must be int")
		}
	}
	return nil
}

// IsInt16 checks to make sure the value is a int16.
// Remains silent if the data is not present.
func IsInt16(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(int16); !ok {
			return errors.New(key + " must be int16")
		}
	}
	return nil
}

// IsInt32 checks to make sure the value is a int32.
// Remains silent if the data is not present.
func IsInt32(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(int32); !ok {
			return errors.New(key + " must be int32")
		}
	}
	return nil
}

// IsInt64 checks to make sure the value is a int64.
// Remains silent if the data is not present.
func IsInt64(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(int64); !ok {
			return errors.New(key + " must be int64")
		}
	}
	return nil
}

// IsInt8 checks to make sure the value is a int8.
// Remains silent if the data is not present.
func IsInt8(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(int8); !ok {
			return errors.New(key + " must be int8")
		}
	}
	return nil
}

// IsRune checks to make sure the value is a rune.
// Remains silent if the data is not present.
func IsRune(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(rune); !ok {
			return errors.New(key + " must be rune")
		}
	}
	return nil
}

// IsString checks to make sure the value is a string.
// Remains silent if the data is not present.
func IsString(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(string); !ok {
			return errors.New(key + " must be string")
		}
	}
	return nil
}

// IsUint checks to make sure the value is a uint.
// Remains silent if the data is not present.
func IsUint(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(uint); !ok {
			return errors.New(key + " must be uint")
		}
	}
	return nil
}

// IsUint16 checks to make sure the value is a uint16.
// Remains silent if the data is not present.
func IsUint16(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(uint16); !ok {
			return errors.New(key + " must be uint16")
		}
	}
	return nil
}

// IsUint32 checks to make sure the value is a uint32.
// Remains silent if the data is not present.
func IsUint32(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(uint32); !ok {
			return errors.New(key + " must be uint32")
		}
	}
	return nil
}

// IsUint64 checks to make sure the value is a uint64.
// Remains silent if the data is not present.
func IsUint64(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(uint64); !ok {
			return errors.New(key + " must be uint64")
		}
	}
	return nil
}

// IsUint8 checks to make sure the value is a uint8.
// Remains silent if the data is not present.
func IsUint8(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(uint8); !ok {
			return errors.New(key + " must be uint8")
		}
	}
	return nil
}

// IsUintptr checks to make sure the value is a uintptr.
// Remains silent if the data is not present.
func IsUintptr(data map[string]interface{}, key string) error {
	if v, ok := data[key]; ok {
		if _, ok := v.(uintptr); !ok {
			return errors.New(key + " must be uintptr")
		}
	}
	return nil
}
